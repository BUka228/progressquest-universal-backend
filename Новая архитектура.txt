полностью переделай арихтектуру на новую (главное не меняй основную логику), потом проверь линтом для firebase и задеплой. Новая архитектура (ты должен ее реализовать полностью):

 Текущая структура, где вся логика для сущности лежит в одном файле (users.ts, tasks.ts), хороша для быстрого старта, но не для масштабирования.
Предлагаю перейти на модульную архитектуру, ориентированную на фичи (Feature-Based Architecture). Это не просто "разложить по папочкам". Это фундаментальное улучшение, которое повысит читаемость, тестируемость и удобство добавления нового функционала.
Философия Новой Архитектуры
Разделение по Доменам, а не по Типам: Вместо папок http, pubsub, types, мы будем создавать папки для каждой бизнес-сущности: user, team, workspace, task, gamification и т.д.
Вертикальные Срезы (Vertical Slices): Каждая папка-фича будет содержать всё, что к ней относится: её API-эндпоинты, бизнес-логику (use cases/services), типы данных и, возможно, вспомогательные утилиты.
Тонкий Слой API: Файлы, определяющие Cloud Functions (onCall, onMessagePublished), должны быть максимально "тонкими". Их задача — принять запрос, проверить аутентификацию и базовые аргументы, вызвать класс/функцию с бизнес-логикой и вернуть результат. Вся "мясная" логика уходит глубже.
Чистая Бизнес-Логика: Ядро каждой фичи — это сервисы или use-кейсы, которые не зависят от Firebase. Они принимают простые аргументы, работают с репозиториями и возвращают результат. Их легко тестировать изолированно.
Централизованный index.ts: Главный index.ts будет лишь импортировать и ре-экспортировать готовые функции из модулей, оставаясь чистым и декларативным.
Предлагаемая Структура Папок
Вот как будет выглядеть новая, масштабируемая структура вашего бэкенда:
functions/
└── src/
    ├── features/                  // <-- Основная папка с бизнес-логикой
    │   ├── user/                  // <-- Модуль "Пользователь"
    │   │   ├── api/               // Функции, которые мы экспортируем
    │   │   │   ├── user.http.ts   // getCurrentUserProfile, updateUserProfile и т.д.
    │   │   │   └── auth.trigger.ts// onUserCreate, onUserDelete
    │   │   ├── domain/            // Бизнес-логика (Use Cases/Services)
    │   │   │   ├── UpdateUserProfileUseCase.ts
    │   │   │   └── RegisterFcmTokenUseCase.ts
    │   │   ├── repository/        // Доступ к данным
    │   │   │   └── UserRepository.ts
    │   │   ├── types/             // Специфичные для модуля типы
    │   │   │   └── user.types.ts
    │   │   └── index.ts           // Экспортирует всё из ./api/
    │   │
    │   ├── workspace/             // <-- Модуль "Рабочее пространство"
    │   │   ├── api/
    │   │   │   └── workspace.http.ts
    │   │   ├── domain/
    │   │   │   └── CreateWorkspaceUseCase.ts
    │   │   ├── repository/
    │   │   └── index.ts
    │   │
    │   ├── task/                  // <-- Модуль "Задача"
    │   │   ├── api/
    │   │   │   ├── task.http.ts
    │   │   │   └── subtask.http.ts
    │   │   ├── domain/
    │   │   └── index.ts
    │   │
    │   ├── gamification/          // <-- Модуль "Геймификация"
    │   │   ├── api/
    │   │   │   ├── badge.http.ts
    │   │   │   └── challenge.http.ts
    │   │   ├── pubsub/            // Обработчики Pub/Sub для геймификации
    │   │   │   ├── taskCompletion.handler.ts
    │   │   │   └── pomodoroCompletion.handler.ts
    │   │   ├── domain/
    │   │   │   ├── AwardBadgeUseCase.ts
    │   │   │   └── ChallengeProcessor.ts // <-- Ваша текущая логика
    │   │   └── index.ts
    │   │
    │   └── ... (другие модули: team, view, pomodoro, statistics)
    │
    ├── core/                      // <-- Общий, переиспользуемый код
    │   ├── types/                 // Общие типы (SuccessResponse, etc.)
    │   │   └── api.types.ts
    │   ├── utils/                 // Общие утилиты
    │   │   └── auth.utils.ts      // assertAuthenticated, assertTeamRole
    │   └── index.ts
    │
    ├── config.ts                  // <-- Глобальные константы (имена коллекций)
    └── index.ts                   // <-- Главный входной файл, очень чистый




План Рефакторинга (пошаговая инструкция)
Мы проведем рефакторинг безопасно, шаг за шагом, не ломая работающий функционал.
Подготовка (Создание Структуры):
Создать новую структуру папок (features, core и подпапки внутри них).
Переместить config.ts в корень src/.
Создать src/core/utils/auth.utils.ts и перенести туда assertAuthenticated и другие общие хелперы.
Создать src/core/types/api.types.ts и перенести туда общие типы вроде SuccessResponse.
Рефакторинг Модуля user (на его примере):
В src/features/user/api/ создать user.http.ts.
Перенести все функции onCall из старого http/users.ts в новый user.http.ts.
В src/features/user/api/ создать auth.trigger.ts и перенести туда триггеры onUserCreate и onUserDelete из auth/index.ts.
Извлечь бизнес-логику: Для каждой onCall функции в user.http.ts (например, updateUserProfile) создать соответствующий файл в src/features/user/domain/ (например, UpdateUserProfileUseCase.ts). Перенести туда основную логику работы с Firestore и другими сервисами.
Было: updateUserProfile = onCall(..., async (req) => { ... много логики ... });
Станет: updateUserProfile = onCall(..., async (req) => { const uid = assert...; return await new UpdateUserProfileUseCase().execute(uid, req.data); });
Создать src/features/user/index.ts, который экспортирует все функции из api/: export * from './api/user.http'; export * from './api/auth.trigger';.
Обновить главный src/index.ts, добавив export * from './features/user';.
Повторить для Остальных Модулей:
Поочередно проделать Шаг 2 для workspace, task, gamification и других фич.
Pub/Sub обработчики (например, onPomodoroPhaseCompletedUpdateGamificationAndStats) переносятся в папку pubsub/ соответствующего модуля. Например, этот обработчик логично положить в src/features/gamification/pubsub/pomodoro.handler.ts, так как он изменяет состояние геймификации в ответ на событие Pomodoro.
Очистка: После того как все функции и триггеры будут перенесены в новую структуру, старые папки http, auth, pubsub можно безопасно удалить.
Преимущества Новой Архитектуры
Масштабируемость: Добавление новой фичи (например, "Аналитика") сводится к созданию новой папки src/features/analytics/ со своей внутренней структурой, не затрагивая существующие.
Удобство Навигации: Сразу понятно, где искать код, относящийся к задачам (features/task/), а где — к пользователям (features/user/).
Низкая Связность, Высокая Сцепленность (Low Coupling, High Cohesion): Код, относящийся к одной фиче, лежит вместе. Модули слабо зависят друг от друга, взаимодействуя через четко определенные API и события.
Тестируемость: Легко писать юнит-тесты для сервисов/use-кейсов в domain/, так как они не привязаны к Firebase и их зависимости можно легко мокировать.
Командная Работа: Разные разработчики могут параллельно работать над разными фичами в разных папках, минимизируя конфликты слияния.